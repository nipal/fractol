/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   new_printing.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <marvin@42.fr>                     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/10/14 00:36:43 by fjanoty           #+#    #+#             */
/*   Updated: 2016/12/05 03:09:53 by fjanoty          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "fractol.h"
#include "c_maths.h"
#include <mlx.h>

void					actu_win_rest(t_win *w)
{
	mlx_put_image_to_window(w->e->mlx, w->win, w->img, 0, 0);
	mlx_do_sync(w->e->mlx);
	ft_bzero(w->data, sizeof(t_pix) * w->size_x * w->size_y);
}

void					actu_win(t_win *w)
{
	mlx_put_image_to_window(w->e->mlx, w->win, w->img, 0, 0);
	mlx_do_sync(w->e->mlx);
}

void					draw_line3(t_matline *ml, t_win *w)
{
	t_matrix	*mat_line;
	t_matrix	*diff;
	double		norme;

	mat_line = NULL;
	diff = NULL;
	if (!ml || !(mat_line = matrix_init(14, 1))
		|| !ml->pt1 || !ml->pt2 || !ml->c1 || !ml->c2
		|| ((!(diff = matrix_sub(ml->pt2, ml->pt1)) && matrix_free(&mat_line))))
		return ;
	diff->m[Z] = 0;
	norme = MAX(ABS(diff->m[0]), ABS(diff->m[1]));
	mat_line->m[NORME] = norme;
	matrix_scalar_product(diff, 1 / norme);
	ft_memmove(mat_line->m, ml->pt1->m, sizeof(double) * 3);
	ft_memmove(mat_line->m + 3, ml->c1->m, sizeof(double) * 3);
	ft_memmove(mat_line->m + 6, diff->m, sizeof(double) * 3);
	matrix_free(&diff);
	matrix_scalar_product(diff = matrix_sub(ml->c2, ml->c1), 1 / norme);
	ft_memmove(mat_line->m + 9, diff->m, sizeof(double) * 3);
	matrix_free(&diff);
	draw_line2(w, mat_line);
}

t_matrix				*define_node_color(double dist_frac, double iter
		, double prog_iter)
{
	t_matrix	*color;

	if (dist_frac < 0 || iter < 0 || prog_iter < 0 || dist_frac > 1 || iter > 1
			|| prog_iter > 1)
	{
		ft_putstr("color param error\n");
		return (NULL);
	}
	return ((color = tsl_to_rvb_new(360 * dist_frac, iter, prog_iter)));
}

/*
void					actual_node_color(t_matrix *col, double dist_frac
		, double iter, double prog_iter)
{
	t_matrix	*color;
	
	printf("yoooooooooooooooooooooooooo@@@@@@@@@@@@@@@\n");
	if (dist_frac < 0 || iter < 0 || prog_iter < 0 || dist_frac > 1 || iter > 1)
		return ;
	if (!(color = tsl_to_rvb_new(360 * dist_frac, iter, prog_iter)))
		return ;
	col->m[0] = color->m[0];
	col->m[1] = color->m[1];
	col->m[2] = color->m[2];
	matrix_free(&color);
}
*/

/*
double					get_polygone_len(t_polygone *seg)
{
	double	i;

	i = 0;
	while (seg)
	{
		seg = seg->next;
		i++;
	}
	return (i);
}
*/
int						init_coef_draw(t_coef_draw *cd, t_polygone *seg
		, double iter, double len_mult)
{
	if (!cd || !seg)
		return (0);
	cd->iter = iter;
	cd->len_seg = get_polygone_len(seg);
	cd->du_dist = pow(1.0 / len_mult, iter) / cd->len_seg;
	cd->to_insert = NULL;
	return (1);
}

int						init_coef_const(t_coef_const *cc, t_polygone *mult
		, double max_iter, t_win *w)
{
	if (!w || !cc || !mult || !(cc->diff = matrix_init(1, 3)))
		return (0);
	cc->dist = 0;
	cc->max_iter = max_iter;
	cc->len_mult = get_polygone_len(mult);
	cc->min_val_trans = get_min_dist(mult);
	cc->mult = mult;
	cc->w = w;
	if (!(cc->diff = matrix_init(1, 3)))
		return (0);
	cc->mouse = w->mouse;
	cc->prev_mouse = w->prev_mouse;
	return (1);
}

int						destroy_coef_const(t_coef_const *cc)
{
	if (cc)
		matrix_free(&(cc->diff));
	return (1);
}

void					vectpx_to_img2(t_win *win, t_matrix *pos_color)
{
	int		x;
	int		y;

	x = (int)pos_color->m[0];
	y = (int)pos_color->m[1];
	if (!win || !pos_color || x < 0 || x >= win->size_x || y < 0
			|| y >= win->size_y)
		return ;
	win->data[y * win->size_x + x].nb = ((int)(pos_color->m[3])) << 16
		| ((int)(pos_color->m[4])) << 8 | (int)pos_color->m[5];
}

int						draw_line2(t_win *win, t_matrix *mat_line)
{
	int			i;
	int			size;
	t_matrix	*diff;
	t_matrix	*org;
	t_matrix	*print;

	if (!(mat_line)
		|| !(diff = matrix_init(6, 1))
		|| !(org = matrix_init(6, 1)))
		return (0);
	i = -1;
	ft_memmove(org->m, mat_line->m, sizeof(double) * 6);
	ft_memmove(diff->m, mat_line->m + 6, sizeof(double) * 6);
	size = (int)(mat_line->m[NORME] + 0.5);
	while (++i < size)
	{
		if (!(print = matrix_add(org, diff)))
			return (0);
		vectpx_to_img2(win, print);
		matrix_free(&org);
		org = print;
	}
	matrix_free(&diff);
	matrix_free(&org);
	return (1);
}

void					translate_node2(t_env *e, t_polygone *poly)
{
	t_polygone *node;

	if ((node = get_closer_node(poly, e->prev_mouse, e->r_select)))
	{
		node->pos->m[0] += e->mouse->m[0] - e->prev_mouse->m[0];
		node->pos->m[1] += e->mouse->m[1] - e->prev_mouse->m[1];
		polygone_destroy(&(e->transform));
		e->transform = transform(poly);
	}
}

void					draw_vertice(t_win *w, t_polygone *seg)
{
	double		pc[6];
	t_matrix	*pos_color;

	pc[0] = seg->pos->m[0];
	pc[1] = seg->pos->m[1];
	pc[3] = 250;
	pc[4] = 250;
	pc[5] = 250;
	if (!seg || !w || !(pos_color = vect_new_vert(pc, 6)))
		return ;
	vectpx_to_img2(w, pos_color);
	matrix_free(&pos_color);
}

void					draw_verticies(t_win *w, t_polygone *seg)
{
	while (seg)
	{
		draw_vertice(w, seg);
		seg = seg->next;
	}
}

void					draw_vertice1(t_env *e, t_polygone *seg)
{
	double		pc[6];
	t_matrix	*pos_color;

	pc[0] = seg->pos->m[0];
	pc[1] = seg->pos->m[1];
	pc[3] = 250;
	pc[4] = 250;
	pc[5] = 250;
	if (!seg || !e || !(pos_color = vect_new_vert(pc, 6)))
		return ;
	vectpx_to_img(e, pos_color);
	matrix_free(&pos_color);
}

void					draw_verticies1(t_env *e, t_polygone *seg)
{
	while (seg)
	{
		draw_vertice1(e, seg);
		seg = seg->next;
	}
}

static	inline	void	init_pt(t_matrix *pta, t_matrix *ptb, double *data
		, int no)
{
	pta->x = 1 + (no * 0);
	ptb->x = 1;
	pta->y = 3;
	ptb->y = 3;
	pta->m = data;
	ptb->m = data + 3;
}

void					draw_simple_polygone(t_win *w, t_polygone *node)
{
	static	double			data[6];
	static	t_matrix		pta;
	static	t_matrix		ptb;
	static	int				init = 1;
	t_matrix				*mt;

	mt = NULL;
	init = 1;
	if (init)
		init_pt(&pta, &ptb, data, (init = 0));
	if (!node)
		return ;
	while (node->next)
	{
		if (!get_pos_to_draw(w, node, &pta, &ptb)
			|| !(mt = init_mat_line(&pta, &ptb, node->col, node->next->col)))
		{
			node = node->next;
			matrix_free(&mt);
			continue ;
		}
		draw_line2(w, mt);
		matrix_free(&mt);
		node = node->next;
	}
}
